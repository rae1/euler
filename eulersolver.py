class EulerSolver():
    def __init__(self):
        pass

    def solve(self, problem):
        if problem == 1:
            return self.solve_problem_one()
        elif problem == 2:
            return self.solve_problem_two()
        else:
            return 0

    def solve_problem_one(self):
        """
        Multiples of 3 and 5
        Problem 1
        If we list all the natural numbers below 10 that are multiples of 3 or 5,
        we get 3, 5, 6 and 9. The sum of these multiples is 23.
        Find the sum of all the multiples of 3 or 5 below 1000.
        """
        return self.find_sum_of_multiples(1000, [3, 5])

    def solve_problem_two(self):
        """
        Each new term in the Fibonacci sequence is generated by
        adding the previous two terms. By starting with 1 and 2,
        the first 10 terms will be:

        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

        Find the sum of all the even-valued terms in the sequence
        which do not exceed four million.
        """
        return self.find_sum_of_even_fibonacci_terms(4000000)

    def find_sum_of_multiples(self, limit, numbers):
        total_sum = sum(self.find_all_divisible_in_range(limit, numbers))
        return total_sum

    def find_all_divisible_in_range(self, limit, numbers):
        def is_multiple_of(numerator):
            return lambda denominator: numerator % denominator == 0

        for current in range(1, limit):
            multiple = map(is_multiple_of(current), numbers)
            if any(multiple):
                yield current

    def find_sum_of_even_fibonacci_terms(self, limit):
        return sum(self.find_all_fibonacci_terms_less_than(limit, lambda term: term % 2 == 0))

    def find_all_fibonacci_terms_less_than(self, limit, filter_func=lambda term: True):
        previous_term, current_term = 1, 1
        matching_terms = []

        if filter_func(previous_term):
            matching_terms.append(previous_term)

        if filter_func(current_term):
            matching_terms.append(current_term)

        next_term = 0
        while next_term < limit:
            next_term = current_term + previous_term
            if next_term < limit and filter_func(next_term):
                matching_terms.append(next_term)
            previous_term = current_term
            current_term = next_term

        return matching_terms